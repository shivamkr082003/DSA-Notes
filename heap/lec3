#include <iostream>
#include<queue>
using namespace std;

class Info{
  public:
    int data;
    int rowIndex;
    int colIndex;

    Info(int a, int b, int c) {
      this->data = a;
      this->rowIndex = b;
      this->colIndex = c;
    }
};

class compare{
  public:
    bool operator()(Info* a, Info* b) {
      return a->data > b->data;
    } 
};

void mergeKSortedArrays(int arr[][4], int n, int k , vector<int> &ans) {

    priority_queue<Info*, vector<Info*>, compare> pq;

    //1 step : process firsk k elements
    for(int row =0; row<k; row++) {
      int element = arr[row][0];
      Info* temp = new Info(element, row,0);
      pq.push(temp);
    }

    while(!pq.empty()) {
      Info* temp = pq.top();
      pq.pop();
      int topData = temp->data;
      int topRow = temp->rowIndex;
      int topCol = temp->colIndex;

      //store in ans vector
      ans.push_back(topData);

      //next element for the same row, jisme se pop kia h just abhi
      //use insert bhi toh karna hai
      if(topCol + 1 < n) {
        //iska matlab row me or element abhi present hai
        Info* newInfo = new Info(arr[topRow][topCol+1], topRow, topCol+1);
        pq.push(newInfo);
      }
    }
}

int main() {
  int arr[3][4] = {
                {1,4,8,11},
                {2,3,6,10},
                {5,7,12,14}
  };
  int n = 4;
  int k = 3;

  vector<int> ans;
  mergeKSortedArrays(arr, n, k , ans);

  cout << "printing Ans array: " << endl;
  for(int i=0; i<ans.size(); i++) {
    cout << ans[i] << " ";
  }

  return 0;
}





/**
 * Definition for singly-linked list.
 * struct ListNode {
 *     int val;
 *     ListNode *next;
 *     ListNode() : val(0), next(nullptr) {}
 *     ListNode(int x) : val(x), next(nullptr) {}
 *     ListNode(int x, ListNode *next) : val(x), next(next) {}
 * };
 */
 class compare{
     public:
        bool operator()(ListNode* a, ListNode* b) {
            return a->val > b->val;
        } 
 };
class Solution {
public:
    ListNode* mergeKLists(vector<ListNode*>& lists) {

        priority_queue<ListNode*, vector<ListNode*>, compare> pq;

        //process first element of every LL
        for(int i=0; i<lists.size(); i++) {
            ListNode* listHead = lists[i];
            if(listHead != NULL) {
                pq.push(listHead);
            }
        }

        ///for new LL
        ListNode* head = NULL;
        ListNode* tail = NULL;

        while(!pq.empty()) {
            ListNode* topNode = pq.top();
            pq.pop();

            //ye frontNode jo nikali h, 
            //ye hamari first node ho
            if(head == NULL) {
                ///pehli node insert krra hu
                head = topNode;
                tail = topNode;
                if(tail->next != NULL) {
                    pq.push(tail->next);
                }
            }
            else {
                //pehle ke baad me koi node insert krra hu
                tail->next = topNode;
                tail = topNode;
                if(tail->next != NULL) {
                    pq.push(tail->next);
                }
            }
        }

    return head;  
    }
};






class Info{
  public:
    int data;
    int rowIndex;
    int colIndex;

    Info(int a, int b, int c) {
      this->data = a;
      this->rowIndex = b;
      this->colIndex = c;
    }
};

class compare{
  public:
    bool operator()(Info* a, Info* b) {
      return a->data > b->data;
    } 
};

class Solution {
public:
    vector<int> smallestRange(vector<vector<int>>& nums) {
        
        priority_queue<Info*, vector<Info*>, compare> pq;
        int maxi = INT_MIN;
        int mini = INT_MAX;

        //process first k elements ko 
        for(int i=0; i<nums.size(); i++) {
            int element = nums[i][0];
            int row = i;
            int col = 0;
            Info* temp = new Info(element, row, col);
            pq.push(temp);
            maxi = max(maxi, element);
            mini = min(mini,element);
        }

        int ansStart = mini;
        int ansEnd = maxi;

        while(!pq.empty()) {
            Info* topNode = pq.top();
            int topData = topNode->data;
            int topCol = topNode->colIndex;
            int topRow = topNode->rowIndex;

            pq.pop();

            mini = topNode->data;
            //maxi ki value pehle se padi hui h 
            //compare krlete h for smaller range
            if((maxi-mini) < (ansEnd-ansStart)) {
                //update ans;
                ansStart  = mini;
                ansEnd = maxi;
            }

            //insertion wala step
            if(topCol + 1 < nums[topRow].size()) {
                int newElement = nums[topRow][topCol+1];
                maxi = max(maxi, newElement);
                Info* newInfo = new Info(newElement, topRow, topCol+1);
                pq.push(newInfo);
            }
            else {
                //aggge koi element nahi h push krne ko
                break;
            }


        }
        vector<int> ans;
        ans.push_back(ansStart);
        ans.push_back(ansEnd);
        return ans;

    }
};




